<!DOCTYPE html>
<!--
    This is almost vanilla from https://tonejs.github.io/Midi/ right now,
    but I want to work some of Keybiano.html into it.  A user can drag a midi file
    onto the page, and it will have the ability to choose one of the tracks.
    The tracks will appear as notes and mapped keys at first, but eventually, I want to
    animate the mapped keys based on when they will play and how long they need to be played.
-->
<html>

<head>
    <title>Midiestro</title>
    <!--
    <script src="https://unpkg.com/vue@2.6.12/dist/vue.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/tone@latest/build/Tone.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@tonejs/midi"></script>
    -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css" integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <script src="Libraries/vue.min.js"></script>
    <script type="text/javascript" src="Libraries/Tone.js"></script>
    <script type="text/javascript" src="Libraries/ToneMidi.js"></script>

    <link href="../Styles.css" rel="stylesheet">
    </link>
    <script src="MyComponents/ToneHelper.js"></script>
    <script src="MyComponents/SynthKeyPlayer.js"></script>
    <script src="MyComponents/keyNoteMaps.js"></script>
    <script src="MyComponents/SongNoteRenderer.js"></script>
    <script src="MyComponents/keyRenderInfo.js"></script>
    <script src="MyComponents/VisibleFieldFilterer.js"></script>
    <script src="MyComponents/ScoreKeeper.js"></script>
    <script src="MyComponents/SongCompression.js"></script>

    <!-- local songs -->
    <script src="PublicDomainSongs/matachins_small.js"></script>
    <script src="PublicDomainSongs/bach_2partinvention.js"></script>
    <script src="PublicDomainSongs/bach_prelude.js"></script>
    <script src="PublicDomainSongs/teleman_sonata.js"></script>
    <script src="PublicDomainSongs/debussy_gollycake.js"></script>
</head>

<body>
    <div id="toneContent">
        <div id="Instructions" class="bordered">
            <h2>Instructions</h2>
            <p>
                This page is a musical typing game, where you can take a midi file and try to match the notes played on your keyboard for points!
            </p>
            <p>
                To play:
                <ul>
                    <li>Drop a midi file on the panel below.</li>
                    <li>Press the Play button.</li>
                    <li>Watch the falling keys, and try to press the key when it gets to the bottom of the game window.</li>
                </ul>
            </p>
            <p>
                As a simple song to start with, here is a place to download <a href="https://onlinesequencer.net/4101480#">Mary Had a Little Lamb</a> .  On the website, choose "Download MIDI"
            </p>
            <p>
                You can find more midi files to download and try out at the links below.  Also searching the internet with a phrase like "Nightmare Before Christmas MIDI" will find songs to download as well.
                <ul>
                    <li>
                        <a href="https://bbloomf.github.io/lilypond-songs">https://bbloomf.github.io/lilypond-songs</a>
                    </li>
                    <li>
                        <a href="https://onlinesequencer.net/sequences">https://onlinesequencer.net/sequences</a>
                    </li>
                    <li>
                        <a href="http://www.soundswell.co.uk/pages/swmids.htm">http://www.soundswell.co.uk/pages/swmids.htm</a>
                    </li>
                </ul>
            </p>
            <div id="FileDrop">
                <div id="Text">
                    Drop a midi file here, or click to select a file from the wizard.  Or use the select box below to choose a Preloaded Song instead.
                </div>
                <input type="file" accept="audio/midi" />
            </div>
        </div>
        <button id="toggleInstructions" onclick="toggleElementById('Instructions')">Toggle Instructions And Advanced Song Selection</button>
        
    </div>
    <div id="app">
        <div id="jsonSongConfig" class="bordered">
            <div class="bordered">
                <label for="jsonSongSelect">Select a Preloaded Song</label>
                <select id="jsonSongSelect" v-model="selectedJsonSong" class="pure-input-rounded" v-on:change="handleJsonSongSelection()">
                    <option v-for="(item, key, index) in jsonSongs" :value="item">{{key}}</option>
                </select>
            </div>
        </div>
        <div id="gameConfig" class="bordered" >
            <div class="bordered">
                Please note: most of these options require the song to be restarted in order to take affect.
            </div>
            <!-- trackOptionConfig -->
            <div id="trackOptionConfig" class="side-by-side">
                <div class="bordered">
                    <label for="trackSelect">Select Track to play</label>
                    <select id="trackSelect" v-model="selectedTrack" class="pure-input-rounded" v-on:change="renderSongNotes()">
                        <option v-for="(item, key, index) in availableTracks" :value="item">{{item.name}} ({{ item.notes.length }} notes, starts at {{ item.notes[0].time }})</option>
                    </select>
                </div>
                <div class="bordered">
                    If you want to play the parts of a particular track, you can select an individual one to display here.  Otherwise notes from all tracks will be used to display.
                </div>
            </div>
            <!-- keyNoteMapConfig -->
            <div id="keyNoteMapConfig" class="side-by-side">
                <div class="bordered">
                    <label for="keyNoteMapSelect">Select a Keyboard Layout</label>
                    <select id="keyNoteMapSelect" v-model="selectedKeyNoteMap" class="pure-input-rounded" v-on:change="renderSongNotes()">
                        <option v-for="(item, key, index) in availableKeyNoteMaps" :value="item">{{key}}</option>
                    </select>
                </div>
                <div class="bordered">
                    {{selectedKeyNoteMap.description}}
                </div>
            </div>
            <!-- maxKeyCount 
             Commenting this one out right now because the multi key behavior stopped working.  May try this out again later, when I stop being such a scrub at the game.
            <div id="maxKeyCount" class="side-by-side">
                <div class="bordered">
                    <label for="maxKeyCountRadio">Max Keys at Once</label>
                    <input type="radio" id="keyCount1" name="maxKeyCountRadio" v-model="selectedKeyCount" value="1" checked></input>
                    <label for="keyCount1">1</label>
                    <input type="radio" id="keyCount2" name="maxKeyCountRadio" v-model="selectedKeyCount" value="2"></input>
                    <label for="keyCount2">2</label>
                    <input type="radio" id="keyCount3" name="maxKeyCountRadio" v-model="selectedKeyCount" value="3"></input>
                    <label for="keyCount3">3</label>
                </div>
                <div class="bordered">
                    This is how many keys will appear to match at one point in time. (The browser will sometimes not recognize more than 2 keys at once, so the 3rd option could appear not to work with all key combinations.)
                </div>
            </div>
            -->
            <!-- minDurationConfig -->
            <div id="minDurationConfig" class="side-by-side">
                <div class="bordered">
                    <div id="minDuration">
                        <label for="minDuration">Min Note Duration (in seconds) {{minDuration}}</label>
                        <input type="range" class="fullRange" id="minDuration" v-model="minDuration" min="0" max="1" step=".01"></input>
                    </div>
                </div>
                <div class="bordered">
                    This sets which notes will be considered playable based on how long they appear on the screen.  the smaller the value, the more notes will show up to play.
                </div>
            </div>
            <!-- minNoteDistanceConfig -->
            <div id="minNoteDistanceConfig" class="side-by-side">
                <div class="bordered">
                    <div id="minNoteDistance">
                        <label for="minNoteDistance">Min Note Distance (in seconds) {{minNoteDistance}}</label>
                        <input type="range" class="fullRange" id="minNoteDistance" v-model="minNoteDistance" min="0" max="1" step=".01"></input>
                    </div>
                </div>
                <div class="bordered">
                    This sets which notes will be considered playable based on how much time is between notes.  the smaller the value, the more notes will show up to play.
                </div>
            </div>
            <!-- trackVolumeConfig -->
            <div id="trackVolumeConfig" class="side-by-side">
                <div class="bordered">
                    <div id="trackVolume">
                        <label for="trackVolume">Track Volume {{trackVolume}}</label>
                        <input type="range" class="fullRange" id="trackVolume" v-model="trackVolume" min="0" max="1" step=".01"></input>
                    </div>
                </div>
                <div class="bordered">
                    This sets the volume of each track.  The smaller the value, the quieter the background music will be.  Please note that this config will only get applied once when the song starts playing.
                </div>
            </div>
            <!-- playerVolumeConfig -->
            <div id="playerVolumeConfig" class="side-by-side">
                <div class="bordered">
                    <div id="playerVolume">
                        <label for="playerVolume">Player Volume {{playerVolume}}</label>
                        <input type="range" class="fullRange" id="playerVolume" v-model="playerVolume" min="0" max="1" step=".01"></input>
                    </div>
                </div>
                <div class="bordered">
                    This sets the volume of the player's audio.  The smaller the value, the quieter the notes played on the keyboard will be.
                </div>
            </div>
        </div>
        <button id="toggleGameConfig" onclick="toggleElementById('gameConfig')">Toggle Game Configurations</button>

        <div id="playProgress">
            <button id="tonePlayToggle" onclick="togglePlay()" disabled>Play</button>
            <span>Score: [{{ score }}]  Good [{{ goodCount }}] Ok [{{ okCount }}] Bad [{{badCount}}] Missed [{{missedCount}}]</span>
        </div>
        <div id="canvasContainer" class="bordered">
            <canvas id="notesCanvas"></canvas>
        </div>
        <div id="keyboardForcer">
            <input type="text" value="" id="keyboardInput" v-model="keyInput"></input>
        </div>
        <div id="notesPlaying">
            <div class="bordered">{{renderedNotesPlaying}}</div>
            <button id="copyMidiJson" onclick="copyMidiJsonToClipboard()">Copy Json to Clipboard</button>
            <div class="bordered">{{ midiJson }}</div>
        </div>
        <div class="side-by-side" id="songNoteKeys">
            <div class="bordered">Mapped Keys<br />{{ songNotesOnKeyMap }}</div>
            <div class="bordered">Song Notes<br />{{ songNotes }}</div>
        </div>
    </div>

    <script type="text/javascript">
        //If the user enters something after the url, like http://url.com?debug
        //The window.location.search field holds everything after the main url
        const queryString = window.location.search;
        const debugPage = queryString == "?debug";
        if(!debugPage){
            toggleElementById('songNoteKeys');
            toggleElementById('notesPlaying');
        }
        const jsonSongs = {
            "Thoinot Arbeau - Les Bouffons (Mattachins)": getArbeauMatachins(),
            "Johann Sebastian Bach - 2 Part Inventions": getBach2PartInvention(),
            "Johann Sebastian Bach - Prelude Number 1": getBachPrelude(),
            "Georg Philipp Telemann - Sonata": getTelemannSonata(),
            "Claude Debussy - Golliwog's Cakewalk": getGollyCake()
        };
        var synthKeyPlayer = getSynthKeyPlayer();
        var songNoteRenderer = getSongNoteRenderer();
        const keyRenderInfo = getKeyRenderInfo();
        var noteLetterCache = songNoteRenderer.buildSongNoteLetterCache(keyRenderInfo);
        var toneHelper = getToneHelper();
        var visibleFieldFilterer = getVisibleFieldFilterer();
        var synthMap = {};
        var songEnd = null;
        const synthArray = [];  //Holds all the available synths
        const pressedKeys = {}; //Holds which keys are pressed down on the keyboard
        //Get all the keyNoteMaps
        const keyNoteMapCollection = getKeyNoteMaps();  //Supplied from ./keyNoteMap.js        
        //Get all the available keyNoteMapKeys keys
        const keyNoteMapKeys = Object.keys(keyNoteMapCollection);
        //Get a default value for the keyNoteMap
        const defaultKeyNoteMap = keyNoteMapCollection[keyNoteMapKeys[0]];
        //The current keys
        var defaultNotesPlaying = "";
        var defaultSongNotes = "";
        var defaultSongNotesOnKeyMap = "";
        var defaultFMSynthParams = toneHelper.getDefaultFMSynthParams();
        const songCompression = getSongCompression();

        //Disposes of existing synths and creates synths based on FMSynth options
        //First call uses the default
        toneHelper.buildSynths(defaultFMSynthParams, synthArray, 10); //Max of three keys for the whole game.
        var app; //The Vue.js variable

        /*
            Any time a user presses a key down on the keyboard:
                Check if the key is in the selected keyNoteMap
                If it is, add it as pressed in the pressedKeys object
                Then run the playNotes method to handle reading the pressedKeys and handling them

                If the key is the space key, just play the conga for "4n" time units
                More about time units: https://tonejs.github.io/docs/14.9.17/types/Unit.Time.html
        */
        document.addEventListener("keydown", function(event) {
            if (event.key in app.selectedKeyNoteMap.keyNoteMap) {
                writeLog("Pressed key for " + app.selectedKeyNoteMap.keyNoteMap[event.key]);
                app.keyInput = "";
                pressedKeys[event.key] = true;
                playNotes();
            }
        });

        /*
            When the user releases a key, the pressedKey for it should stop appearing as pressed
                Then run playNotes again to handle playing the notes in pressedKeys
        */
        document.addEventListener("keyup", function() {
            if(event.key in app.selectedKeyNoteMap.keyNoteMap && event.key in synthMap){
                writeLog("Release key for " + app.selectedKeyNoteMap.keyNoteMap[event.key]);
                pressedKeys[event.key] = false;
                playNotes();
            }
        });

        /*
            Resets the Notes Playing field on the page
            Evaluates which keys are pressed
                If any keys are pressed
                    Gets the notes mapped to the pressed keys
                    Assigns free synths
                    Starts playing the synths
                If any synths are playing for a key that is not pressed
                    Stops playing the synth

        */
        function playNotes(){
            synthKeyPlayer.playNotes(app, pressedKeys, synthMap, synthArray);
        }

        //Hiding console debug logs behind the "?debug" string in the url, like https://austin183.github.io/MidiSongBuilder/Keybiano.html?debug
        function writeLog(logEntry){
            if(debugPage == true){
                console.log(logEntry);
            }
        }

        if (
            !(
                window.File &&
                window.FileReader &&
                window.FileList &&
                window.Blob
            )
        ) {
            document.querySelector("#FileDrop #Text").textContent =
                "Reading files not supported by this browser";
        } else {
            const fileDrop = document.querySelector("#FileDrop");

            fileDrop.addEventListener("dragenter", () =>
                fileDrop.classList.add("Hover")
            );

            fileDrop.addEventListener("dragleave", () =>
                fileDrop.classList.remove("Hover")
            );

            fileDrop.addEventListener("drop", () =>
                fileDrop.classList.remove("Hover")
            );

            document
                .querySelector("#FileDrop input")
                .addEventListener("change", (e) => {
                    //get the files
                    const files = e.target.files;
                    if (files.length > 0) {
                        const file = files[0];
                        document.querySelector(
                            "#FileDrop #Text"
                        ).textContent = file.name;
                        parseFile(file);
                    }
                });
        }

        let currentMidi = null;

        function parseFile(file) {
            //read the file
            const reader = new FileReader();
            reader.onload = function (e) {
                app.availableTracks = [];
                const midi = new Midi(e.target.result);
                var trimmedMidi = {"tracks": []};
                var counter = 0;
                midi.tracks.forEach((track) => {
                    counter++;
                    if(track.notes.length > 0){
                        var trackName = track.name;
                        if(trackName == ""){
                            trackName = "Track";
                        }
                        trackName += " " + counter;
                        var trimmedTrack = {
                            "name" : trackName,
                            "notes" : track.notes
                        }
                        app.availableTracks.push(trimmedTrack);
                        trimmedMidi.tracks.push(trimmedTrack);
                    }
                });

                var playButton = document.getElementById('tonePlayToggle');
                playButton.removeAttribute('disabled');
                playButton.textContent = 'Play';

                currentMidi = trimmedMidi;
                var fullNotes = getCombinedTrackNotes(currentMidi.tracks);
                var fullTrack = {
                    "name" : "Full Track",
                    "notes": fullNotes
                }
                // Add the fullTrack as the first array element in app.availableTracks
                app.availableTracks.unshift(fullTrack);

                app.selectedTrack = app.availableTracks[0];
                var lastNote = fullTrack.notes[fullTrack.notes.length - 1];
                songEnd = lastNote.time + lastNote.duration;
                renderSongNotes();
                //To get the premade function file version
                app.midiJson = "function getRENAMEMETHOD() { return " + JSON.stringify(getCompressedJson()) + "};"
                //To get the prettified version
                //app.midiJson = JSON.stringify(currentMidi, null, 2);
            };
            reader.readAsArrayBuffer(file);
        }

        function getCombinedTrackNotes(tracks){
            var combinedNotes = [];
            tracks.forEach(track => {
                combinedNotes.push(...track.notes);
            });

            combinedNotes.sort((a, b) => a.time - b.time);

            return combinedNotes;
        }

        const synths = [];
        var playing = false;
        var playIntervalId = {};
        const delay = 3; //This is to give the player a chance to prepare before the first note plays

        function togglePlay() {
            var invertedKeyNoteMap = songNoteRenderer.invertKeyNoteMap(app.selectedKeyNoteMap.keyNoteMap);
            var playButton = document.getElementById('tonePlayToggle');
            playing = !playing;
            if(playing == true){
                playButton.textContent = 'Stop';
            }
            else{
                playButton.textContent = 'Restart';
            }
            if (playing && currentMidi) {
                document.getElementById('keyboardInput').focus();
                const scoreKeeper = getScoreKeeper();
                const containerElement = document.getElementById("canvasContainer");
                containerElement.scrollIntoView({ behavior: "smooth" });
                const startTime = Tone.now();
                const futureLimit = songEnd;
                const visibleField = visibleFieldFilterer.filterToFullVisibleField(app.selectedTrack.notes, app.minNoteDistance, app.minDuration, invertedKeyNoteMap, app.selectedKeyCount, keyRenderInfo, app.notesCanvas, songNoteRenderer);
                var earliestNoteIndex = 0;
                currentMidi.tracks.forEach((track) => {
                    //create a synth for each track
                    const synth = new Tone.PolySynth(Tone.Synth, {
                        envelope: {
                            attack: 0.02,
                            decay: 0.1,
                            sustain: 0.3,
                            release: 1,
                        },
                    }).toDestination();
                    synths.push(synth);
                    //schedule all of the events
                    track.notes.forEach((note) => {
                        if(note.duration > 0){
                            synth.triggerAttackRelease(
                                note.name,
                                note.duration,
                                note.time + startTime + delay,
                                note.velocity * app.trackVolume
                            );
                        }                        
                    });
                });
                playIntervalId = setInterval(() => {
                    const intervalNow = Tone.now() - startTime - delay;
                    const visiblePast = intervalNow - 1;
                    const visibleFuture = intervalNow + 9;
                    if(visiblePast > songEnd){
                        app.vueCanvas.clearRect(0, 0, app.notesCanvas.width, app.notesCanvas.height);
                        renderFinalScore(app.notesCanvas, app.vueCanvas, app.score, app.goodCount, app.okCount, app.badCount, app.missedCount);
                        togglePlay(); //Should end the song automatically at the end.
                        return;
                    }
                    
                    for(var i = earliestNoteIndex; i < visibleField.length; i++){
                        const note = visibleField[i];
                        if(note.time + note.duration < visiblePast){
                            earliestNoteIndex = i;
                        }
                        else{
                            break;
                        }
                    }
                    
                    var currentScore = scoreKeeper.calculateNewScore(visibleField, pressedKeys, intervalNow, earliestNoteIndex, visibleFuture);
                    app.score = currentScore.total;
                    var counts = scoreKeeper.getCounts();
                    app.goodCount = counts.goodCount;
                    app.okCount = counts.okCount;
                    app.badCount = counts.badCount;
                    app.missedCount = counts.missedCount;
                    if(debugPage == true){
                        app.renderedNotesPlaying = songNoteRenderer.renderDebugNotesPlaying(app.notesCanvas, app.selectedTrack.notes, currentScore, invertedKeyNoteMap, keyRenderInfo, intervalNow, visiblePast);
                    }
                    app.vueCanvas.clearRect(0, 0, app.notesCanvas.width, app.notesCanvas.height);
                    songNoteRenderer.renderNowLine(app.notesCanvas, app.vueCanvas);
                    songNoteRenderer.renderNotesPlayingForCanvas(app.notesCanvas, app.vueCanvas, visibleField, currentScore, intervalNow, visiblePast, visibleFuture, earliestNoteIndex, noteLetterCache);
                }, 10);

            } else {
                clearInterval(playIntervalId);
                app.renderNotesPlaying = "";                
                Tone.Transport.stop();
                Tone.Transport.position = 0;
                Tone.Transport.cancel();

                //dispose the synth and make a new one
                while (synths.length) {                    
                    const synth = synths.shift();
                    synth.disconnect();
                    synth.dispose();                                  
                }
            }
        };

        function renderFinalScore(canvas, ctx, total, goodCount, okCount, badCount, missedCount) {
            var maxHeight = canvas.height;
            var maxWidth = canvas.width;
            var rowHeight = canvas.height / 10;
            var initialXPosition = (canvas.width / 10) * 2;
            var initialYPosition = rowHeight * 2;
            ctx.font="20px Georgia";
            // Create gradient
            var gradient=ctx.createLinearGradient(0,0,canvas.width,0);
            gradient.addColorStop("0","magenta");
            gradient.addColorStop("0.5","blue");
            gradient.addColorStop("1.0","red");
            // Fill with gradient
            ctx.fillStyle=gradient;
            ctx.fillText("Total: " + total, initialXPosition, initialYPosition);
            ctx.fillStyle = "green";
            ctx.fillText("Good: " + goodCount, initialXPosition, initialYPosition + rowHeight + 10);
            ctx.fillStyle = "yellow";
            ctx.fillText("OK: " + okCount, initialXPosition, initialYPosition + (rowHeight * 2) + 20);
            ctx.fillStyle = "red";
            ctx.fillText("Bad: " + badCount, initialXPosition, initialYPosition + (rowHeight * 3) + 30);
            ctx.fillStyle = "blue";
            ctx.fillText("Missed: " + missedCount, initialXPosition, initialYPosition + (rowHeight * 4) + 40);
        };

        //This function shows or hides the FMSynthConfigs div
        function toggleElementById(id) {
            var configDiv = document.getElementById(id); // Get a reference to the synth configuration DIV element by its ID (you may need to replace 'id' with actual id of your HTML structure)
            if (configDiv) {
                const currentDisplayState = configDiv.style.display;

                if (currentDisplayState === "none") { // If it is currently hidden, then show the div (change its display style to block or inline-block as appropriate for your layout)
                    configDiv.style.display = "";

                } else { // Otherwise assume that FMSynthConfigs are already visible and hide them by setting their display property back to none
                    configDiv.style.display = "none";
                }
            }
        }
        toggleElementById('Instructions');
        toggleElementById('gameConfig')

        //Once everything is downloaded, and the page has loaded, start rendering the Vue.js app
        window.onload = function(){
            app = new Vue({
                el: '#app', //The div id to put the Vue.js app in.  I can end sentences with prepositions if I want.  It's what my repo is really about!
                data: {
                    selectedKeyNoteMap: defaultKeyNoteMap, //Which keyboard map the user has selected in the drop down.
                    availableKeyNoteMaps: keyNoteMapCollection, //All the keyboard maps available in the drop down
                    renderedNotesPlaying: defaultNotesPlaying, //The field to show which notes are playing based on the keys pressed at the time
                    songNotes: defaultSongNotes,
                    songNotesOnKeyMap: defaultSongNotesOnKeyMap,
                    selectedKeyCount: 1,
                    selectedTrack: "",
                    availableTracks: [],
                    vueCanvas: null,
                    notesCanvas: null,
                    score: 0,
                    goodCount: 0,
                    okCount: 0,
                    badCount: 0,
                    missedCount: 0,
                    minDuration: .1,
                    minNoteDistance: .4,
                    playerVolume: .7,
                    trackVolume: 1,
                    midiJson: "",
                    jsonSongs: jsonSongs,
                    selectedJsonSong: null,
                    keyInput: ""
                },
                mounted(){
                    this.notesCanvas = document.getElementById("notesCanvas")
                    var ctx = notesCanvas.getContext('2d');
                    this.vueCanvas = ctx;
                    this.vueCanvas.clearRect(0, 0, this.notesCanvas.width, this.notesCanvas.height);
                    this.vueCanvas.font = "18px Georgia";
                    this.vueCanvas.fillStyle = "black";
                    this.vueCanvas.fillText("Watch for falling note keys!", 0, 50); // Assuming the height of the letter is about 20 pixels
                }
            });

        };

        function renderSongNotes(){
            if(currentMidi  && app.selectedTrack !== "" && debugPage){
                var invertedKeyNoteMap = songNoteRenderer.invertKeyNoteMap(app.selectedKeyNoteMap.keyNoteMap);
                var renderedSongNotes = "";
                var renderedSongNotesOnKeyMap = "";
                var song = app.selectedTrack.notes;
                writeLog(JSON.stringify(song));
                var renderedNotes = songNoteRenderer.renderSongNotes(song, app.selectedKeyNoteMap.keyNoteMap);

                app.songNotes = renderedNotes.renderedSongNotes;
                app.songNotesOnKeyMap = renderedNotes.renderedSongNotesOnKeyMap;
                app.renderedNotesPlaying = songNoteRenderer.renderDebugNotesPlaying(song, invertedKeyNoteMap, 0);
            }
        }

        function handleJsonSongSelection(){
            if(app.selectedJsonSong){
                app.availableTracks = []
                var decompressedSong = getDecompressedSong();
                currentMidi = decompressedSong;
                currentMidi.tracks.forEach(track => {
                    app.availableTracks.push(track);
                });
                var fullNotes = getCombinedTrackNotes(currentMidi.tracks);
                var fullTrack = {
                    "name" : "Full Track",
                    "notes": fullNotes
                }
                // Add the fullTrack as the first array element in app.availableTracks
                app.availableTracks.unshift(fullTrack);
                
                app.selectedTrack = app.availableTracks[0];
                var lastNote = fullTrack.notes[fullTrack.notes.length - 1];
                songEnd = lastNote.time + lastNote.duration;
                renderSongNotes();
                app.midiJson = JSON.stringify(currentMidi, null, 2);
                renderSongNotes();
                var playButton = document.getElementById('tonePlayToggle');
                playButton.removeAttribute('disabled');
                playButton.textContent = 'Play';
            }
        }

        function copyMidiJsonToClipboard(){
            navigator.clipboard.writeText(app.midiJson);
            //Change the copyMidiJson text to "Copied!" for a second, and then change it back to "Copy Json to Clipboard" after a few seconds
            // Use setTimeout() to delay the display of the copied message
            setTimeout(function(){
                document.getElementById('copyMidiJson').textContent = 'Copied!';
            }, 100);

            // Use setTimeout() again to reset the text to its original value
            setTimeout(function(){
                document.getElementById('copyMidiJson').textContent = 'Copy Json to Clipboard';
            }, 3000);

        }

        function getDecompressedSong(){ 
            return songCompression.getDecompressedSong(app.selectedJsonSong.tracks);
        }

        function getCompressedJson(){
            return songCompression.getCompressedJson(app.availableTracks);
        }

        function clearKeyboardInput(){
            app.keyboardInput = "";
        }

    </script>
</body>

</html>